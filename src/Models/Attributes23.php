<?php

declare(strict_types=1);

/*
 * Form3PublicAPILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

namespace Form3PublicAPILib\Models;

use Form3PublicAPILib\Utils\DateTimeHelper;
use stdClass;

class Attributes23 implements \JsonSerializable
{
    /**
     * @var string|null
     */
    private $amount;

    /**
     * @var BeneficiaryParty3|null
     */
    private $beneficiaryParty;

    /**
     * @var string|null
     */
    private $categoryPurpose;

    /**
     * @var string|null
     */
    private $categoryPurposeCoded;

    /**
     * @var string|null
     */
    private $clearingId;

    /**
     * @var string|null
     */
    private $currency;

    /**
     * @var DebtorParty2|null
     */
    private $debtorParty;

    /**
     * @var string|null
     */
    private $endToEndReference;

    /**
     * @var string|null
     */
    private $instructionId;

    /**
     * @var bool|null
     */
    private $mandateAmendmentIndicator;

    /**
     * @var string|null
     */
    private $mandateId;

    /**
     * @var \DateTime|null
     */
    private $mandateSignatureDate;

    /**
     * @var string|null
     */
    private $numericReference;

    /**
     * @var string|null
     */
    private $paymentPurposeCoded;

    /**
     * @var string|null
     */
    private $paymentScheme;

    /**
     * @var \DateTime|null
     */
    private $processingDate;

    /**
     * @var string|null
     */
    private $reference;

    /**
     * @var string|null
     */
    private $remittanceInformation;

    /**
     * @var string|null
     */
    private $schemePaymentType;

    /**
     * @var \DateTime|null
     */
    private $schemeProcessingDate;

    /**
     * @var string|null
     */
    private $schemeStatus;

    /**
     * @var string|null
     */
    private $schemeTransactionId;

    /**
     * @var Settlement|null
     */
    private $settlement;

    /**
     * @var StructuredReference|null
     */
    private $structuredReference;

    /**
     * @var UltimateEntity|null
     */
    private $ultimateBeneficiary;

    /**
     * @var UltimateEntity|null
     */
    private $ultimateDebtor;

    /**
     * @var string|null
     */
    private $uniqueSchemeId;

    /**
     * Returns Amount.
     * Amount of money moved between the instructing agent and instructed agent
     */
    public function getAmount(): ?string
    {
        return $this->amount;
    }

    /**
     * Sets Amount.
     * Amount of money moved between the instructing agent and instructed agent
     *
     * @maps amount
     */
    public function setAmount(?string $amount): void
    {
        $this->amount = $amount;
    }

    /**
     * Returns Beneficiary Party.
     */
    public function getBeneficiaryParty(): ?BeneficiaryParty3
    {
        return $this->beneficiaryParty;
    }

    /**
     * Sets Beneficiary Party.
     *
     * @maps beneficiary_party
     */
    public function setBeneficiaryParty(?BeneficiaryParty3 $beneficiaryParty): void
    {
        $this->beneficiaryParty = $beneficiaryParty;
    }

    /**
     * Returns Category Purpose.
     * Category purpose in proprietary form. Specifies the high level purpose of the instruction. Cannot be
     * used at the same time as `category_purpose_coded`.
     */
    public function getCategoryPurpose(): ?string
    {
        return $this->categoryPurpose;
    }

    /**
     * Sets Category Purpose.
     * Category purpose in proprietary form. Specifies the high level purpose of the instruction. Cannot be
     * used at the same time as `category_purpose_coded`.
     *
     * @maps category_purpose
     */
    public function setCategoryPurpose(?string $categoryPurpose): void
    {
        $this->categoryPurpose = $categoryPurpose;
    }

    /**
     * Returns Category Purpose Coded.
     * Category purpose in a coded form. Specifies the high level purpose of the instruction. Cannot be
     * used at the same time as `category_purpose`.
     */
    public function getCategoryPurposeCoded(): ?string
    {
        return $this->categoryPurposeCoded;
    }

    /**
     * Sets Category Purpose Coded.
     * Category purpose in a coded form. Specifies the high level purpose of the instruction. Cannot be
     * used at the same time as `category_purpose`.
     *
     * @maps category_purpose_coded
     */
    public function setCategoryPurposeCoded(?string $categoryPurposeCoded): void
    {
        $this->categoryPurposeCoded = $categoryPurposeCoded;
    }

    /**
     * Returns Clearing Id.
     * Unique identifier for organisations collecting payments
     */
    public function getClearingId(): ?string
    {
        return $this->clearingId;
    }

    /**
     * Sets Clearing Id.
     * Unique identifier for organisations collecting payments
     *
     * @maps clearing_id
     */
    public function setClearingId(?string $clearingId): void
    {
        $this->clearingId = $clearingId;
    }

    /**
     * Returns Currency.
     * Currency of the transaction amount. Currency code as defined in [ISO 4217](http://www.iso.
     * org/iso/home/standards/currency_codes.htm)
     */
    public function getCurrency(): ?string
    {
        return $this->currency;
    }

    /**
     * Sets Currency.
     * Currency of the transaction amount. Currency code as defined in [ISO 4217](http://www.iso.
     * org/iso/home/standards/currency_codes.htm)
     *
     * @maps currency
     */
    public function setCurrency(?string $currency): void
    {
        $this->currency = $currency;
    }

    /**
     * Returns Debtor Party.
     */
    public function getDebtorParty(): ?DebtorParty2
    {
        return $this->debtorParty;
    }

    /**
     * Sets Debtor Party.
     *
     * @maps debtor_party
     */
    public function setDebtorParty(?DebtorParty2 $debtorParty): void
    {
        $this->debtorParty = $debtorParty;
    }

    /**
     * Returns End to End Reference.
     * Unique identification, as assigned by the initiating party, to unambiguously identify the
     * transaction. This identification is passed on, unchanged, throughout the entire end-to-end chain.
     */
    public function getEndToEndReference(): ?string
    {
        return $this->endToEndReference;
    }

    /**
     * Sets End to End Reference.
     * Unique identification, as assigned by the initiating party, to unambiguously identify the
     * transaction. This identification is passed on, unchanged, throughout the entire end-to-end chain.
     *
     * @maps end_to_end_reference
     */
    public function setEndToEndReference(?string $endToEndReference): void
    {
        $this->endToEndReference = $endToEndReference;
    }

    /**
     * Returns Instruction Id.
     * Unique identification, as assigned by the initiating party to unambiguously identify the transaction.
     * This identification is an point-to-point reference and is passed on, unchanged, throughout the
     * entire chain. Cannot include leading, trailing or internal spaces.
     */
    public function getInstructionId(): ?string
    {
        return $this->instructionId;
    }

    /**
     * Sets Instruction Id.
     * Unique identification, as assigned by the initiating party to unambiguously identify the transaction.
     * This identification is an point-to-point reference and is passed on, unchanged, throughout the
     * entire chain. Cannot include leading, trailing or internal spaces.
     *
     * @maps instruction_id
     */
    public function setInstructionId(?string $instructionId): void
    {
        $this->instructionId = $instructionId;
    }

    /**
     * Returns Mandate Amendment Indicator.
     * Indicator notifying whether the underlying mandate is amended or not
     */
    public function getMandateAmendmentIndicator(): ?bool
    {
        return $this->mandateAmendmentIndicator;
    }

    /**
     * Sets Mandate Amendment Indicator.
     * Indicator notifying whether the underlying mandate is amended or not
     *
     * @maps mandate_amendment_indicator
     */
    public function setMandateAmendmentIndicator(?bool $mandateAmendmentIndicator): void
    {
        $this->mandateAmendmentIndicator = $mandateAmendmentIndicator;
    }

    /**
     * Returns Mandate Id.
     * Original mandate id.
     */
    public function getMandateId(): ?string
    {
        return $this->mandateId;
    }

    /**
     * Sets Mandate Id.
     * Original mandate id.
     *
     * @maps mandate_id
     */
    public function setMandateId(?string $mandateId): void
    {
        $this->mandateId = $mandateId;
    }

    /**
     * Returns Mandate Signature Date.
     * Date on which the direct debit mandate has been signed by the debtor.
     */
    public function getMandateSignatureDate(): ?\DateTime
    {
        return $this->mandateSignatureDate;
    }

    /**
     * Sets Mandate Signature Date.
     * Date on which the direct debit mandate has been signed by the debtor.
     *
     * @maps mandate_signature_date
     * @factory \Form3PublicAPILib\Utils\DateTimeHelper::fromSimpleDate
     */
    public function setMandateSignatureDate(?\DateTime $mandateSignatureDate): void
    {
        $this->mandateSignatureDate = $mandateSignatureDate;
    }

    /**
     * Returns Numeric Reference.
     * Numeric reference field, see scheme specific descriptions for usage
     */
    public function getNumericReference(): ?string
    {
        return $this->numericReference;
    }

    /**
     * Sets Numeric Reference.
     * Numeric reference field, see scheme specific descriptions for usage
     *
     * @maps numeric_reference
     */
    public function setNumericReference(?string $numericReference): void
    {
        $this->numericReference = $numericReference;
    }

    /**
     * Returns Payment Purpose Coded.
     * Purpose of the direct debit in a coded form
     */
    public function getPaymentPurposeCoded(): ?string
    {
        return $this->paymentPurposeCoded;
    }

    /**
     * Sets Payment Purpose Coded.
     * Purpose of the direct debit in a coded form
     *
     * @maps payment_purpose_coded
     */
    public function setPaymentPurposeCoded(?string $paymentPurposeCoded): void
    {
        $this->paymentPurposeCoded = $paymentPurposeCoded;
    }

    /**
     * Returns Payment Scheme.
     * Clearing infrastructure through which the operation instruction is to be processed. Default for
     * given organisation ID is used if left empty. Has to be a valid [scheme identifier](http://draft-api-
     * docs.form3.tech/api.html#enumerations-schemes).
     */
    public function getPaymentScheme(): ?string
    {
        return $this->paymentScheme;
    }

    /**
     * Sets Payment Scheme.
     * Clearing infrastructure through which the operation instruction is to be processed. Default for
     * given organisation ID is used if left empty. Has to be a valid [scheme identifier](http://draft-api-
     * docs.form3.tech/api.html#enumerations-schemes).
     *
     * @maps payment_scheme
     */
    public function setPaymentScheme(?string $paymentScheme): void
    {
        $this->paymentScheme = $paymentScheme;
    }

    /**
     * Returns Processing Date.
     * Date on which the operation is to be debited from the debtor account. Formatted according to ISO
     * 8601 format: YYYY-MM-DD.
     */
    public function getProcessingDate(): ?\DateTime
    {
        return $this->processingDate;
    }

    /**
     * Sets Processing Date.
     * Date on which the operation is to be debited from the debtor account. Formatted according to ISO
     * 8601 format: YYYY-MM-DD.
     *
     * @maps processing_date
     * @factory \Form3PublicAPILib\Utils\DateTimeHelper::fromSimpleDate
     */
    public function setProcessingDate(?\DateTime $processingDate): void
    {
        $this->processingDate = $processingDate;
    }

    /**
     * Returns Reference.
     * Payment reference for beneficiary use
     */
    public function getReference(): ?string
    {
        return $this->reference;
    }

    /**
     * Sets Reference.
     * Payment reference for beneficiary use
     *
     * @maps reference
     */
    public function setReference(?string $reference): void
    {
        $this->reference = $reference;
    }

    /**
     * Returns Remittance Information.
     * Information supplied to enable the matching of an entry with the items that the transfer is intended
     * to settle, such as commercial invoices in an accounts receivable system provided by the debtor for
     * the beneficiary.
     */
    public function getRemittanceInformation(): ?string
    {
        return $this->remittanceInformation;
    }

    /**
     * Sets Remittance Information.
     * Information supplied to enable the matching of an entry with the items that the transfer is intended
     * to settle, such as commercial invoices in an accounts receivable system provided by the debtor for
     * the beneficiary.
     *
     * @maps remittance_information
     */
    public function setRemittanceInformation(?string $remittanceInformation): void
    {
        $this->remittanceInformation = $remittanceInformation;
    }

    /**
     * Returns Scheme Payment Type.
     * The [scheme-specific payment type](#enumerations-scheme-payment-types)
     */
    public function getSchemePaymentType(): ?string
    {
        return $this->schemePaymentType;
    }

    /**
     * Sets Scheme Payment Type.
     * The [scheme-specific payment type](#enumerations-scheme-payment-types)
     *
     * @maps scheme_payment_type
     */
    public function setSchemePaymentType(?string $schemePaymentType): void
    {
        $this->schemePaymentType = $schemePaymentType;
    }

    /**
     * Returns Scheme Processing Date.
     * Date on which the operation is processed by the scheme. Formatted according to ISO 8601 format: YYYY-
     * MM-DD. Only used if different from `processing_date`.
     */
    public function getSchemeProcessingDate(): ?\DateTime
    {
        return $this->schemeProcessingDate;
    }

    /**
     * Sets Scheme Processing Date.
     * Date on which the operation is processed by the scheme. Formatted according to ISO 8601 format: YYYY-
     * MM-DD. Only used if different from `processing_date`.
     *
     * @maps scheme_processing_date
     * @factory \Form3PublicAPILib\Utils\DateTimeHelper::fromSimpleDate
     */
    public function setSchemeProcessingDate(?\DateTime $schemeProcessingDate): void
    {
        $this->schemeProcessingDate = $schemeProcessingDate;
    }

    /**
     * Returns Scheme Status.
     * This reference is used by the receiving party to identify whether the related DDI would have been
     * electronic (AUDDIS) or paper‐based.
     */
    public function getSchemeStatus(): ?string
    {
        return $this->schemeStatus;
    }

    /**
     * Sets Scheme Status.
     * This reference is used by the receiving party to identify whether the related DDI would have been
     * electronic (AUDDIS) or paper‐based.
     *
     * @maps scheme_status
     * @factory \Form3PublicAPILib\Models\SchemeStatusEnum::checkValue
     */
    public function setSchemeStatus(?string $schemeStatus): void
    {
        $this->schemeStatus = $schemeStatus;
    }

    /**
     * Returns Scheme Transaction Id.
     * Unique identification, as assigned by the first instructing agent, to unambiguously identify the
     * transaction that is passed on, unchanged, throughout the entire interbank chain.
     */
    public function getSchemeTransactionId(): ?string
    {
        return $this->schemeTransactionId;
    }

    /**
     * Sets Scheme Transaction Id.
     * Unique identification, as assigned by the first instructing agent, to unambiguously identify the
     * transaction that is passed on, unchanged, throughout the entire interbank chain.
     *
     * @maps scheme_transaction_id
     */
    public function setSchemeTransactionId(?string $schemeTransactionId): void
    {
        $this->schemeTransactionId = $schemeTransactionId;
    }

    /**
     * Returns Settlement.
     * Specifies the details on how the settlement of the transaction between the instructing agent and the
     * instructed agent is completed
     */
    public function getSettlement(): ?Settlement
    {
        return $this->settlement;
    }

    /**
     * Sets Settlement.
     * Specifies the details on how the settlement of the transaction between the instructing agent and the
     * instructed agent is completed
     *
     * @maps settlement
     */
    public function setSettlement(?Settlement $settlement): void
    {
        $this->settlement = $settlement;
    }

    /**
     * Returns Structured Reference.
     */
    public function getStructuredReference(): ?StructuredReference
    {
        return $this->structuredReference;
    }

    /**
     * Sets Structured Reference.
     *
     * @maps structured_reference
     */
    public function setStructuredReference(?StructuredReference $structuredReference): void
    {
        $this->structuredReference = $structuredReference;
    }

    /**
     * Returns Ultimate Beneficiary.
     */
    public function getUltimateBeneficiary(): ?UltimateEntity
    {
        return $this->ultimateBeneficiary;
    }

    /**
     * Sets Ultimate Beneficiary.
     *
     * @maps ultimate_beneficiary
     */
    public function setUltimateBeneficiary(?UltimateEntity $ultimateBeneficiary): void
    {
        $this->ultimateBeneficiary = $ultimateBeneficiary;
    }

    /**
     * Returns Ultimate Debtor.
     */
    public function getUltimateDebtor(): ?UltimateEntity
    {
        return $this->ultimateDebtor;
    }

    /**
     * Sets Ultimate Debtor.
     *
     * @maps ultimate_debtor
     */
    public function setUltimateDebtor(?UltimateEntity $ultimateDebtor): void
    {
        $this->ultimateDebtor = $ultimateDebtor;
    }

    /**
     * Returns Unique Scheme Id.
     * The scheme-specific unique transaction ID. Populated by the scheme.
     */
    public function getUniqueSchemeId(): ?string
    {
        return $this->uniqueSchemeId;
    }

    /**
     * Sets Unique Scheme Id.
     * The scheme-specific unique transaction ID. Populated by the scheme.
     *
     * @maps unique_scheme_id
     */
    public function setUniqueSchemeId(?string $uniqueSchemeId): void
    {
        $this->uniqueSchemeId = $uniqueSchemeId;
    }

    /**
     * Encode this object to JSON
     *
     * @param bool $asArrayWhenEmpty Whether to serialize this model as an array whenever no fields
     *        are set. (default: false)
     *
     * @return array|stdClass
     */
    #[\ReturnTypeWillChange] // @phan-suppress-current-line PhanUndeclaredClassAttribute for (php < 8.1)
    public function jsonSerialize(bool $asArrayWhenEmpty = false)
    {
        $json = [];
        if (isset($this->amount)) {
            $json['amount']                      = $this->amount;
        }
        if (isset($this->beneficiaryParty)) {
            $json['beneficiary_party']           = $this->beneficiaryParty;
        }
        if (isset($this->categoryPurpose)) {
            $json['category_purpose']            = $this->categoryPurpose;
        }
        if (isset($this->categoryPurposeCoded)) {
            $json['category_purpose_coded']      = $this->categoryPurposeCoded;
        }
        if (isset($this->clearingId)) {
            $json['clearing_id']                 = $this->clearingId;
        }
        if (isset($this->currency)) {
            $json['currency']                    = $this->currency;
        }
        if (isset($this->debtorParty)) {
            $json['debtor_party']                = $this->debtorParty;
        }
        if (isset($this->endToEndReference)) {
            $json['end_to_end_reference']        = $this->endToEndReference;
        }
        if (isset($this->instructionId)) {
            $json['instruction_id']              = $this->instructionId;
        }
        if (isset($this->mandateAmendmentIndicator)) {
            $json['mandate_amendment_indicator'] = $this->mandateAmendmentIndicator;
        }
        if (isset($this->mandateId)) {
            $json['mandate_id']                  = $this->mandateId;
        }
        if (isset($this->mandateSignatureDate)) {
            $json['mandate_signature_date']      = DateTimeHelper::toSimpleDate($this->mandateSignatureDate);
        }
        if (isset($this->numericReference)) {
            $json['numeric_reference']           = $this->numericReference;
        }
        if (isset($this->paymentPurposeCoded)) {
            $json['payment_purpose_coded']       = $this->paymentPurposeCoded;
        }
        if (isset($this->paymentScheme)) {
            $json['payment_scheme']              = $this->paymentScheme;
        }
        if (isset($this->processingDate)) {
            $json['processing_date']             = DateTimeHelper::toSimpleDate($this->processingDate);
        }
        if (isset($this->reference)) {
            $json['reference']                   = $this->reference;
        }
        if (isset($this->remittanceInformation)) {
            $json['remittance_information']      = $this->remittanceInformation;
        }
        if (isset($this->schemePaymentType)) {
            $json['scheme_payment_type']         = $this->schemePaymentType;
        }
        if (isset($this->schemeProcessingDate)) {
            $json['scheme_processing_date']      = DateTimeHelper::toSimpleDate($this->schemeProcessingDate);
        }
        if (isset($this->schemeStatus)) {
            $json['scheme_status']               = SchemeStatusEnum::checkValue($this->schemeStatus);
        }
        if (isset($this->schemeTransactionId)) {
            $json['scheme_transaction_id']       = $this->schemeTransactionId;
        }
        if (isset($this->settlement)) {
            $json['settlement']                  = $this->settlement;
        }
        if (isset($this->structuredReference)) {
            $json['structured_reference']        = $this->structuredReference;
        }
        if (isset($this->ultimateBeneficiary)) {
            $json['ultimate_beneficiary']        = $this->ultimateBeneficiary;
        }
        if (isset($this->ultimateDebtor)) {
            $json['ultimate_debtor']             = $this->ultimateDebtor;
        }
        if (isset($this->uniqueSchemeId)) {
            $json['unique_scheme_id']            = $this->uniqueSchemeId;
        }

        return (!$asArrayWhenEmpty && empty($json)) ? new stdClass() : $json;
    }
}
